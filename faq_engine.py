"""
faq_engine.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pre-trained FAQ store with TF-IDF cosine-similarity retrieval.
  â€¢ Returns a canned answer when confidence > threshold â†’ saves API calls.
  â€¢ Exposes a simple feedback loop: answers that users âœ… are boosted,
    answers that users âŒ are penalised â†’ lightweight "self-learning".
"""

from __future__ import annotations

import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FAQ KNOWLEDGE BASE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
_FAQ_DB: list[dict] = [
    # â”€â”€ identity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "What is your name? Who are you?",
        "answer":   "I'm **DynamiChat** ðŸ¤– â€“ a dynamic, AI-powered chatbot built with Google Gemini, NLP, and Machine Learning. I'm here to chat, help, and learn!",
        "score":    1.0,
    },
    {
        "question": "Are you a real person or a bot?",
        "answer":   "I'm an AI chatbot â€“ not a real person. But I do my best to be helpful and have a natural conversation! ðŸ˜Š",
        "score":    1.0,
    },
    # â”€â”€ capabilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "What can you do? What are your features?",
        "answer":   (
            "Here's what I can do:\n"
            "â€¢ ðŸ’¬ **Chat** â€“ natural conversations on almost any topic\n"
            "â€¢ ðŸ§  **Intent Recognition** â€“ I understand what you're asking\n"
            "â€¢ ðŸ·ï¸  **Entity Extraction** â€“ I spot emails, dates, cities, etc.\n"
            "â€¢ ðŸ˜Š **Sentiment & Emotion Detection** â€“ I sense how you feel\n"
            "â€¢ ðŸ“Š **Analytics Dashboard** â€“ track our conversation stats\n"
            "â€¢ ðŸŽ¯ **FAQ Answers** â€“ instant replies for common questions\n"
            "â€¢ ðŸ¤– **Self-Learning** â€“ I improve based on your feedback!"
        ),
        "score":    1.0,
    },
    {
        "question": "Can you help me with coding or programming?",
        "answer":   "Absolutely! I can help with coding questions, debugging, explanations, and even writing code snippets. Just ask! ðŸ’»",
        "score":    1.0,
    },
    {
        "question": "Can you translate languages?",
        "answer":   "I can help with basic translations and language-related questions. For best results, tell me the source and target language! ðŸŒ",
        "score":    1.0,
    },
    # â”€â”€ how-it-works â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "How does sentiment analysis work?",
        "answer":   (
            "I use a **TF-IDF + Logistic Regression** model trained on labelled data to classify your message as:\n"
            "â€¢ **Polarity**: positive / negative / neutral\n"
            "â€¢ **Emotion**: joy / anger / sadness / fear / surprise / neutral\n"
            "The results show up in the sidebar and influence how I respond!"
        ),
        "score":    1.0,
    },
    {
        "question": "How does intent recognition work?",
        "answer":   (
            "Intent recognition uses a **two-stage pipeline**:\n"
            "1. Fast regex pattern matching for common intents\n"
            "2. TF-IDF cosine-similarity fallback for paraphrases\n"
            "This lets me understand *what* you're asking even if you phrase it differently."
        ),
        "score":    1.0,
    },
    {
        "question": "What is Named Entity Recognition NER?",
        "answer":   "NER extracts important pieces of information from your text â€“ like **emails**, **phone numbers**, **cities**, **dates**, **currencies**, and **names**. I highlight them in the sidebar! ðŸ·ï¸",
        "score":    1.0,
    },
    {
        "question": "What AI model powers you?",
        "answer":   "My responses are generated by **Google Gemini** (gemini-2.0-flash by default). I also use scikit-learn models for sentiment, intent, and FAQ matching â€“ all running locally! ðŸ¤–",
        "score":    1.0,
    },
    # â”€â”€ usage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "How do I give feedback?",
        "answer":   "After each response you'll see ðŸ‘ and ðŸ‘Ž buttons. Tap them to tell me if my answer was helpful â€“ it helps me improve! ðŸŽ¯",
        "score":    1.0,
    },
    {
        "question": "How do I clear the conversation?",
        "answer":   "Click the **ðŸ—‘ï¸ Clear Chat** button in the sidebar to start a fresh conversation. Analytics history is kept unless you also clear that.",
        "score":    1.0,
    },
    {
        "question": "How do I see analytics?",
        "answer":   "Switch to the **ðŸ“Š Analytics Dashboard** tab at the top of the page. It shows intent distribution, sentiment trends, response times, and more!",
        "score":    1.0,
    },
    # â”€â”€ greetings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "Hello hi hey good morning good evening",
        "answer":   "Hey there! ðŸ‘‹ Welcome to **DynamiChat**! How can I help you today? Feel free to ask me anything!",
        "score":    1.0,
    },
    # â”€â”€ thanks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "Thank you thanks appreciate",
        "answer":   "You're welcome! ðŸ˜Š Happy to help. Let me know if there's anything else I can do for you!",
        "score":    1.0,
    },
    # â”€â”€ jokes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "question": "Tell me a joke funny",
        "answer":   "Why did the AI go to therapy? ðŸ¤– Because it had too many **unresolved dependencies**! ðŸ˜„",
        "score":    1.0,
    },
]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TF-IDF RETRIEVER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FAQEngine:
    CONFIDENCE_THRESHOLD = 0.28      # cosine sim above this â†’ use FAQ answer

    def __init__(self) -> None:
        self._db        = list(_FAQ_DB)                 # mutable copy
        self._vectoriser = TfidfVectorizer(ngram_range=(1, 2), max_features=8000)
        self._rebuild_index()

    # â”€â”€ public â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def query(self, text: str) -> tuple[str | None, float]:
        """
        Returns (answer, confidence).
        answer is None when confidence < threshold.
        """
        if not text or not text.strip():
            return None, 0.0

        q_vec  = self._vectoriser.transform([text])
        sims   = cosine_similarity(q_vec, self._q_vecs)[0]

        # weight by learned score (feedback loop)
        scores = np.array([item["score"] for item in self._db])
        weighted = sims * scores

        best_idx  = int(np.argmax(weighted))
        best_conf = float(weighted[best_idx])

        if best_conf >= self.CONFIDENCE_THRESHOLD:
            return self._db[best_idx]["answer"], round(best_conf, 3)
        return None, round(best_conf, 3)

    # â”€â”€ feedback (self-learning) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def feedback(self, text: str, positive: bool) -> None:
        """Boost or penalise the FAQ that matched the user's query."""
        if not text or not text.strip():
            return
        q_vec  = self._vectoriser.transform([text])
        sims   = cosine_similarity(q_vec, self._q_vecs)[0]
        best_idx = int(np.argmax(sims))

        if positive:
            self._db[best_idx]["score"] = min(self._db[best_idx]["score"] * 1.15, 3.0)
        else:
            self._db[best_idx]["score"] = max(self._db[best_idx]["score"] * 0.80, 0.1)

    # â”€â”€ internal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _rebuild_index(self) -> None:
        questions = [item["question"] for item in self._db]
        self._q_vecs = self._vectoriser.fit_transform(questions)
